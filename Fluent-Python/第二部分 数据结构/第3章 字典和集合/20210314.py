"""6、子类化UserDict"""
# 改进StrKeyDict0类，使得所有的键都存储为字符串类型
from collections import UserDict


class StrKeyDict(UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, item):  # 更加简洁，可以假设所有已经存储的键都是字符串
        return str(item) in self.data  # 在self.data上查询

    def __setitem__(self, key, value):  # 将所有键转换成字符串
        self.data[str(key)] = value


"""7、不可变映射类型"""
# 从Python 3.3开始，types模块中引入了一个封装类名叫 MappingProxyType。如果给这个类一个映射，它会返回一个只读的映射视图。虽然只是个只读视图，但是它是动态的，这意味着如果对源映射
# 做出了改动，可以通过这个视图观察到，但是无法通过这个视图对源映射进行修改
from types import MappingProxyType

d = {1: 'A'}
d_proxy = MappingProxyType(d)  # d_proxy是动态的，对d所做的所有改动都会反馈到它上面
print(d_proxy)
d[2] = 'B'
print(d_proxy)


"""8、集合论"""
# 集合的本质是许多唯一对象的聚集——集合可用于去重。集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以，因为可以创建一个包含不同frozenset的set。
# 集合还实现了很多基础的中缀运算符。给定两个集合a和b，a | b 返回它们的合集，a & b 得到的是交集，而 a - b 得到的是差集。

# 求needles的元素在haystack里出现的次数
needles = {1, 2, 3}
haystack = {1, 2, 3, 4, 5, 6}
# found = len(needles & haystack)
found = len(needles.intersection(haystack))
print(found)


# 集合字面量
# 如果是空集，那么必须写成set()形式
s = {1}
s.pop()
print(s)

# 集合推导
from unicodedata import name  # 用于获取字符的名字

print({chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')})  # 把编码在32~255之间的字符的名字里有'SIGN'单词的挑出来


"""9、dict和set的背后"""
# 字典中的散列表：散列表其实是一个稀疏数组（总有空白元素的数组称为稀疏数组）。散列表中的单元通常叫做表元，在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，
# 一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。Python会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，
# 原有的散列表会被复制到一个更大的空间里面。如果要把一个对象放入散列表，那么首先要计算这个元素键的散列值——hash()方法。

# 散列值和相等性
# 内置的hash()方法可以用于所有的内置类型对象。如果是自定义对象调用hash()的话，实际上运行的是自定义的__hash__。如果两个对象在比较的时候是相等的，那么它们的散列值必须相等，
# 否则散列表就不能正常运行了。越是相似但不相等的对象，它们散列值的差别应该越大。


# 散列表算法
# 为了获取 my_dict[search_key] 背后的值，Python首先会调用hash(search_key)来计算search_key的散列值，把这个值最低的几位数字（具体几位看当前散列表的大小）当作偏移量，
# 在散列表中查找表元。若找到的表元是空的，则抛出KeyError异常；若不是空的，则表元里会有一对 found_key: found_value。这时候检验 search_key == found_key 是否为真，
# 如果相等就返回found_key。

# 散列冲突：如果search_key和found_key不匹配的话，这种情况称为散列冲突。发生这种情况是因为散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字
# 的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊方法处理，把新的到的数字再当作索引来寻找表元。

# 增加散列表的大小有助于减少发生散列冲突的概率——散列值所占的位数和用作索引的位数都会随之增加。


''' dict的实现及其导致的结果 '''
# ①、键必须是可散列的
# 一个可散列的对象必须满足以下要求：
# 第5章 一等函数）支持hash()函数，并且通过__hash__()方法所得到的散列值是不变的
# 2）支持通过__eq_()方法来检测相等性
# 3）若a==b为真，则hash(a) == hash(b)也为真

# ②、字典在内存上的开销巨大
# 由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。用元组取代字典就能节省空间的原因有两个：避免了散列表所耗费的空间；无需把记录中字段的名字在每个元素里都存一遍

# ③、键查询很快
# dict的实现是典型的空间换时间：字典类型有着巨大的内存开销，但它们提供了无视数据量大小的快速访问——只要字典能够被装在内存里。

# ④、键的次序取决于添加顺序
# 当往dict里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置。

# ⑤、往字典里添加新键可能会改变已有键的顺序
# 无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，
# 导致新散列表中键的次序变化。如果在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很有可能会跳过一些键——甚至是跳过那些字典中已经有的键。

# 不要对字典同时进行迭代和修改，如果想扫描并修改一个字典，最好分成两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；迭代结束之后再对原有字典进行更新。


''' set的实现以及导致的结果 '''
# set和frozenset的实现也依赖于散列表，但在它们的散列表里存放的只有元素的引用，特点如下：
# 第5章 一等函数）集合里的元素必须是可散列的
# 2）集合很消耗内存
# 3）可以很高效地判断元素是否存在于某个集合
# 4）元素地次序取决于被添加到集合里的次序
# 5）往集合里添加元素，可能会改变集合里已有元素的次序
